Наследование:
повторное использование интерфейса
Сама по себе идея заключается в том, что объект является удобным инструментом. Он позволяет вам оформлять данные и функциональность вместе, согласно концепции, так что вы можете представить подходящую идею проблемной области раньше, чем начать усиленно использовать идиому лежащей в основе машины. Эта концепция является фундаментом при программировании с использованием ключевого слова class.

Однако это выглядит довольно жалко, решать все проблемы путем создания класса, а затем усиленно создавать качественно новый класс, который может иметь сходную функциональность. Гораздо лучше, если мы можем взять существующий класс, размножить его и создать дополнения и модификации клона. Это результат, который вы получаете при наследовании, за исключением того, что если класс-оригинал (называемый базовый или супер или родительский класс) меняется, модифицируется и “клон” (называемый производный или наследуемый или sub или наследник класс), отражая эти изменения.


Стрелка на приведенной выше UML диаграмме указывает от класса-наследника на базовый класс. Как вы видите, может быть более одного наследуемого класса.)

Тип - это больше чем описание ограничений для набора объектов. Это также взаимные отношения с другими типами. Два типа могут иметь общие характеристики и черты поведения, но один тип может содержать больше характеристик, чем другой, а может обрабатывать больше сообщений (или обрабатывать их иначе). Наследование выражает эту схожесть между типами, используя концепцию базового типа и наследуемого типа. Базовый тип содержит все характеристики и черты поведения, которые есть у всех типов, наследуемых от этого. Вы создаете базовый тип для образования ядра вашей идеи для некоторых объектов в вашей системе. От базового типа вы образуете другие типы для создания разных способов, которыми данное ядро может быть реализовано.

Например, машина по переработке мусора сортирует кусочки мусора. Базовый тип - “мусор”, а каждый кусочек мусора имеет вес, объем и так далее, и может быть разрезан, расплавлен или растворен. Для этих более специфичных типов мусора наследуются типы, которые могут иметь дополнительные характеристики (бутылки имеют цвет) или черты поведения (алюминий может быть раздавлен, а сталь может магнитится). Вдобавок, некоторые черты поведения могут отличаться (объем бумаги зависит от типа и состояния). Используя наследование, вы можете создать иерархические типы, которые выражают проблему, которую вы пробуете решить в терминах своих типов.

Второй пример - это классический пример с “формой”, возможно, используемый компьютерной системе разработки или в игровых симуляторах. Базовый тип - “форма”, а каждая форма имеет размер, цвет, положение и так далее. Каждая форма может быть нарисована, стерта, перемещена, окрашена и т.д. От нее образуются (наследуются) специфические типы: окружность, квадрат, треугольник и так далее, каждый из которых может иметь дополнительные характеристики и черты поведения. Определенные формы могут быть зеркально отражены, например. Некоторые черты поведения могут отличаться, так если вы хотите посчитать площадь формы. Формы иерархически объединяет и похожие и различные черты форм.


Поиск решения в терминах проблемы чрезвычайно полезно, так как у вас нет необходимости массы промежуточных моделей, чтобы перейти от описания проблемы к описанию решения. У объектов в первичной модели типы иерархические, так что вы прямо переходите от описания системы реального мира к описанию системы в кодах. Несомненно, одно из затруднений людей, работающих с объектно-ориентированной разработкой, в том, что слишком просто пройти от начала до конца. Разум, натренированный на поиск сложных решений часто сначала стопорится на такой простоте.

Когда вы наследуете от существующего типа, вы создаете новый тип. Этот новый тип содержит не все члены существующего типа (private члены спрятаны и недоступны), более важно, это дублирование интерфейсов базового класса. То есть, все сообщения, которые вы можете послать объекту базового класса, вы можете послать их объекту наследуемого класса. Так как мы знаем тип класса, которому мы посылаем сообщения, это означает, что наследуемый класс того же типа, что и базовый класс. В предыдущем примере “окружность - это форма”. Такая эквивалентность типов через наследование - это один из основных шлюзов для понимания значения объектно-ориентированного программирования.

Так как оба класса: базовый и наследованный имеют одинаковый интерфейс, должна быть реализация для работы с этим интерфейсом. Таким образом, должен быть определенный код, который выполняется, когда объект принимает определенное сообщение. Если вы просто наследуете класс и ничего больше не делаете, методы интерфейса базового класса переходят без изменения в наследованный класс. Это означает, что объект наследованного класса имеет не только тот же тип, он имеет такие же черты поведения, что обычно не интересно.

Вы имеете два способа сделать ваш новый класс отличным от оригинального базового класса. Первый достаточно прямой: вы просто добавляете несколько новый функций к наследуемому классу. Это означает, что базовый класс просто не делает столько, сколько вам нужно, так что вы добавляете больше функций. Это простое и примитивное использование наследования, одновременно является законченным решением вашей проблемы. Однако вы должны взглянуть более пристально на возможно, что вашему базовому классу может не хватать этих дополнительных функций. Этот процесс обнаружения и повторения при разработке встречается регулярно в объектно-ориентированном программировании.


Хотя наследование иногда может подразумевать (особенно в Java, где ключевое слово, означающее наследование, это extends), что вы хотите добавить новые функции к интерфейсу, это не всегда так. Второй, наиболее важный способ сделать ваш класс отличным, заключается в изменении поведения существующей функции базового класса. Это называется перегрузкой.


Для перегрузки функции вы просто создаете новое определение для функции в наследуемом классе. Вы говорите, “Я использую ту же функцию интерфейса, но я хочу делать что-то другое для моего нового типа.
