Объект имеет интерфейс
Аристотель, вероятно, был первым, кто начал старательно изучать концепцию типа; он говорил: “класс рыбы и класс птицы”. Идея, что все объекты, хотя являются уникальными, также являются частью класса объектов, которые имеют общие характеристики и характер поведения, что было использовано в первом объектно-ориентированном языке Симула-67 с этим основополагающим словом класс, которое ввело новый тип в программу.

Симула, как показывает его название, был создан для разработки симуляторов, таких как классическая “проблема банковского кассира”. В ней вы имеете группу кассиров, клиентов, счетов, переводов и денег — множество “объектов”. Объекты, которые идентичны, за исключением своих состояний во время исполнения программы, группируются вместе в “классы объектов”. Так и пришло ключевое слово класс. Создание абстрактных типов данных (классов) - это основополагающая концепция в объектно-ориентированном программировании. Абстрактные типы данных работают почти так же, как и встроенные типы: вы можете создавать переменные этого типа (называемые объектами или экземплярами, если говорить объектно-ориентированным языком) и манипулировать этими переменными (это называется посылка сообщений или запрос; вы посылаете сообщение и объект смотрит что нужно с ним делать). Члены (элементы) каждого класса распределяются с некоторой унифицированностью: каждый счет имеет баланс, каждый кассир может принимать депозит и т.п. В то же время, каждый член имеет свое собственное состояние, каждый счет имеет различный баланс, каждый кассир имеет имя. Поэтому, кассиры, клиенты, счета, переводы и т.п. могут быть представлены как уникальная сущность в компьютерной программе. Эта сущность и есть объект, а каждый объект принадлежит определенному классу, который определяет характеристики и черты поведения.

Так, несмотря на то, что мы реально делаем в объектно-ориентированном программировании - это создание новых типов, фактически все объектно-ориентированные языки используют ключевое слово “класс”. Когда вы видите слово “тип”, то думайте “класс” и наоборот. [3]

Так как класс описывает набор объектов, которые имеют идентичные характеристики (элементы данных) и черты поведения (функциональность), класс реально является типом данных, потому что, например, число с плавающей точкой также имеет набор характеристик и черт поведения. Отличия в том, что программист определяет класс исходя из проблемы, чтобы представить блок для хранения в машине. Вы расширяете язык программирования, добавляя спецификации новых типов данных, которые вам необходимы. Эта система программирования приветствует новые классы и заботится за ними всеми, выполняя проверку типа, как и для встроенных типов.

Объектно-ориентированный подход не ограничивается построением симуляторов. Независимо от того, согласны вы или нет, что любая разрабатываемая вами программа - это эмуляция системы, использование ООП техники может легко снизить большую часть проблем для упрощения решения.

Как только класс создан, вы можете создать столько объектов этого класса, сколько захотите, а затем манипулировать этими объектами так, как если бы они являлись элементами, которые существуют в проблеме, которую вы пробуете решить. Несомненно, одно из предназначений объектно-ориентированного программирования - это создание связей один-к-одному между элементами в пространстве проблемы и объектами в пространстве решения.

Но как заставить объект стать полезным для вас? Должен существовать способ сделать запрос к объекту, чтобы он что-то сделал, например, законченную транзакцию, что-то нарисовал на экране или включил переключатель. Каждый объект может удовлетворять только определенные запросы. Запросы, которые вы можете сделать к объекту, определяются его интерфейсом и типом, который определяет интерфейс. Простым примером может стать представление электрической лампочки:


Light lt = new Light();
lt.on();
Интерфейс определяет какой запрос вы можете выполнить для определенного объекта. Однако должен существовать определенный код, для удовлетворения этого запроса. Здесь, наряду со спрятанными данными, содержится реализация. С точки зрения процедурного программирования это не сложно. Тип имеет функциональные ассоциации для каждого возможного запроса и, когда вы делаете определенный запрос к объекту, вызывается такая функция. Этот процесс обычно суммируется и можно сказать, что вы “посылаете сообщение” (делаете запрос) объекту, а объект определяет, что он должен сделать с этим сообщением (он исполняет код).

В этом промере имя типа/класса - Light, имя этого обычного объекта Light - lt, а запросы, которые вы можете сделать для объекта Light - это включить его, выключить, сделать ярче или темнее. Вы создаете объект Light, определяя “ссылку” (lt) для объекта и вызываете new для запроса нового объекта этого типа. Для отправки сообщения объекту вы объявляете имя объекта и присоединяете его к сообщению запроса, разделив их (точкой). С точки зрения пользователя, предварительное определение класса - более красивый способ программирования с объектами.

Диаграмма, показанная выше, следует формату Унифицированного Языка Моделирования (Unified Modeling Language (UML). Каждый класс представляется ящиком, с именем типа в верхней части ящика и членами - данными, которые вы описываете в средней части ящика, а члены - функции (принадлежащие объекту функции, которые принимают сообщения, которые вы посылаете этому объекту) в нижней части ящика. Чаще всего только имя класса и публичные члены - функции показаны в диаграмме разработки UML, так что средняя часть не показывается. Если вы интересуетесь только именем класса, нижние части нет необходимости показывать.
